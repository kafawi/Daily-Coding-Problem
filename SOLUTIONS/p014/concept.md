# My first Monte carlo

I never implement an Monte Carlo method but I think, I know enough to implement this stochastical method.

We know the formulat for the area of a quadrat: `Aq = l^2` with `l` := edge length
If we encapsulate the cicle with a quadrat, we know, that the length `l = 2r`
-> `Aq = (2r)^2 = 4r^2`
The area of the circle is `Ac = pi * r^2` 
so the `4` in the quadrat area formular is like the `pi` in the circle

If we calculate the Fraction of the two the two area, we rearrange the formular to the term: 
`Ac / Aq = (pi*r^2) /4*r^2  = pi / 4  -> pi = 4 * Ac / Aq` 

We can get the ration of `Ac/Aq` by placing randomly points in a defind area, The area is the quadrats `Aq` and determind with  `x^2 + y^2 = r^2` if the point is also in the circles `Ac`.
The fraction `(numbers of points in the circle)/(total numbers of points) = Ac/Aq`

To simplify the calculation we just use the positive area of `x` and `y` dimension, so it is more like a quarter pizza, in the upper right corner in the pizza box. we can do this, becaus of the symmetrie of the given geometric figures.

Also we will set the `r = 1` becauss, it does not matter, and this is very simple. 

Then we need a random number generator that generates numbers in a unique distribution between `[0,r]`. Also in math the boundery is infinitely small, so it does not matter if we include the bounds.

For simplicity, I use the builtin random generator.

### When do we know, that we reach the correct precition of the thrid decimal place?

This is acievt with the power of the statistic and the rule of greate numbers.

If the numbers generated by the random generator is truly unique distributed, then we will get the precition of `10^-3` at about `1000`, but to be sure, we have to wait till the next digit, the forth, is no more hard wiggleing and destroy by rounding our result. This is just an estimation, so i will go with batches of `1000` and check the wiggle. But there is maybe a analytic estimation with the Propagation of uncertainty. I will research...

the error is propotional with the factor `4` in `pi = 4 * Ac / Aq`, if we want to get the precition for the batch, we hat to do it `4` times more. So the batch is `4000`.
$\pi = \Delta_\pi = 4 (\frac{A_c}{A_q} + \Delta_A) \leftrightarrow \Delta_\pi = 4\Delta_A$ and $\Delta_\pi < 10^{-3}: \longrightarrow \Delta_A < \frac{1}{4}10^{-3} \longrightarrow$ batch size = $\Delta_A^{-1} = 4000$ 

So we got the desired precition, if we round up to this precision and it stops wiggling for a good amount of runs, because the approximation goes for every run more and more to the correct value, but if it starts with some unlucky bias, we have to make sure that that is more or less no more effecting the outcome for this position. So I choose, because i do not know better, a number `1000=1/10^-3` times, that the outcome has to be stop wiggling. Maybe that is too much.

I guess, this is a okayish solution.

[code](solution.py)

### discussion

There is another trick to get rid of a bias by random. Using ensambles and taking the mean.
By starting `N` smaller simulation, everytime fresh, we can get a good stable value by taking the mean. \[
    \pi = \frac{\sum_i^n{\pi_i}}{n}
    \]